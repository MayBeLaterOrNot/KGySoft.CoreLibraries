using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;
using KGySoft.Libraries.Diagnostics;
using System.Runtime.Serialization;

namespace KGySoft.Libraries
{
    using System.Security;

    #region Types at namespace level

    /// <summary>
    /// Possible behavors of <see cref="Cache{TKey,TValue}"/> when the store is full and an element has to be removed.
    /// </summary>
    /// <seealso cref="Cache{TKey,TValue}"/>
    public enum CacheBehavior
    {
        /// <summary>
        /// When a new element has to be stored and cache is full, then the oldest element will be removed.
        /// May be faster when recently stored elements are accessed more often than older ones or when
        /// cache size is large (more than a few hundred elements). This is the default value when a new <see cref="Cache{TKey,TValue}"/>
        /// instance is created.
        /// </summary>
        RemoveOldestElement,

        /// <summary>
        /// When a new element has to be stored and cache is full, then the least recent used element will be removed.
        /// May be faster for smaller cache sizes (up to about 1000 elements) when even older elements are accessed over and over while is cache is often full
        /// and loading an element is very slow. Using this behavior is highly discouraged for very large cache capacity.
        /// </summary>
        RemoveLeastRecentUsedElement
    }

    /// <summary>
    /// Represents cache statistics retrieved by <see cref="Cache{TKey,TValue}.GetStatistics"/>.
    /// Provides non-generic access to a <see cref="Cache{TKey,TValue}.CacheStatistics"/> structure.
    /// </summary>
    /// <seealso cref="Cache{TKey,TValue}"/>
    public interface ICacheStatistics
    {
        /// <summary>
        /// Gets number of cache reads.
        /// </summary>
        int Reads { get; }

        /// <summary>
        /// Gets number of cache writes.
        /// </summary>
        int Writes { get; }

        /// <summary>
        /// Gets number of cache deletes.
        /// </summary>
        int Deletes { get; }

        /// <summary>
        /// Gets number of cache hits.
        /// </summary>
        int Hits { get; }

        /// <summary>
        /// Gets the hit rate of the cache
        /// </summary>
        float HitRate { get; }
    }

    /// <summary>
    /// Provides a non-generic access to the <see cref="Cache{TKey,TValue}"/> class.
    /// </summary>
    public interface ICache : IDictionary
    {
        /// <summary>
        /// Gets or sets the capacity of the cache.
        /// </summary>
        int Capacity { get; }

        /// <summary>
        /// Gets or sets the cache behavior when cache is full and an element has to be removed.
        /// <para>
        /// Default value: <see cref="CacheBehavior.RemoveOldestElement"/>.
        /// </para>
        /// <note>
        /// Changing value of this property will not reorganize cache. Cache order is maintaned on accessing a value.
        /// </note>
        /// </summary>
        /// <seealso cref="CacheBehavior"/>
        CacheBehavior Behavior { get; set; }

        /// <summary>
        /// Renewes an item in the evaluation order.
        /// </summary>
        /// <param name="key">The key of the item to renew.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="key"/> must exist in the cache.</exception>
        void Touch(object key);

        /// <summary>
        /// Refreshes the value in the cache even if it was already loaded.
        /// </summary>
        /// <param name="key">The key of the item to refresh.</param>
        void RefreshValue(object key);

        /// <summary>
        /// Reloads the value into the cache even if it was already loaded using the item loader that was passed to the constructor.
        /// </summary>
        /// <param name="key">The key of the item to reload.</param>
        /// <returns>Loaded value</returns>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        object GetValueUncached(object key);

        /// <summary>
        /// Clears the cache and resets statistics.
        /// </summary>
        void Reset();

        /// <summary>
        /// Gets statistics of the cache.
        /// </summary>
        ICacheStatistics GetStatistics();
    }

    #endregion

    /// <summary>
    /// Generic cache. Cache expansion is transparent; user needs only to read the <see cref="this"/> property to retrieve items.
    /// When a non-existing key is accessed, then item is loaded automatically by the loader function that was passed to one of the constructors.
    /// If the cache is full (elements <see cref="Count"/> reaches the <see cref="Capacity"/>) and a new element has to be stored, then
    /// the oldest or least recent used element (depends on the value of <see cref="Behavior"/>) is removed from the cache.
    /// </summary>
    /// <typeparam name="TKey">Type of the key</typeparam>
    /// <typeparam name="TValue">Type of the values stored in the cache</typeparam>
    /// <remarks>
    /// <para>
    /// <see cref="Cache{TKey,TValue}"/> type provides a fast-access storage with limited capacity and transparent access. If you need to store
    /// items that are expensive to retrieve (for example from a database or remote service) and you don't want to run out of memory because of
    /// just storing newer and newer elements without getting rid of old ones, then this type might fit your expectations.
    /// </para>
    /// <para>
    /// A cache store must meet the following three criteria:
    /// <list type="number">
    /// <item><term>Associative access</term><description>Accessing elements works the same way as at the <see cref="Dictionary{TKey,TValue}"/> type.
    /// <see cref="Cache{TKey,TValue}"/> implements both the generic <see cref="IDictionary{TKey,TValue}"/> and the non-generic <see cref="IDictionary"/> interfaces so can be
    /// used similarly as <see cref="Dictionary{TKey,TValue}"/> or <see cref="Hashtable"/> types.</description></item>
    /// <item><term>Transparency</term><description>Users of the cache need only to read the cache by its indexer (<see cref="this"/> property). If needed, elements will be
    /// automatically loaded on the first acces.</description></item>
    /// <item><term>Size management</term><description><see cref="Cache{TKey,TValue}"/> type has a <see cref="Capacity"/>, which is the allowed maximal elements count. If the cache is full the
    /// oldest or least recent used element will be automatically removed from the cache (see <see cref="Behavior"/> property).</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// Since <see cref="Cache{TKey,TValue}"/> implements <see cref="IDictionary{TKey,TValue}"/> interface, <see cref="Add"/>, <see cref="Remove"/>, <see cref="ContainsKey"/> and
    /// <see cref="TryGetValue"/> are available for it, and these method work exactly the same way as in case the <see cref="Dictionary{TKey,TValue}"/> type. But using these methods
    /// usually are not neccessary, unless we want to manually manage cache content or when cache is initialized with <see cref="NullLoader"/>. Normally after cache is instantiated,
    /// it is needed to be accessed only by its indexer.
    /// </para>
    /// <note type="caution">
    /// Serializing a cache instance involves the serialization of the item loader delegate. To deserialize a cache the assembly of the loader must be accessible. If you need to
    /// serialize cache instances try to use static methods as data loaders and avoid using anonymous delegates or lambda expressions, otherwise it is not guaranteed that another
    /// implementations or versions of CLR will able to deserialize data and resolve the compiler-generated members.
    /// </note>
    /// </remarks>
    /// <example>
    /// The following example shows the suggested usage of <see cref="Cache{TKey,TValue}"/>.
    /// <code lang="C#">
    ///using System;
    ///using System.Collections.Generic;
    ///
    ///using KGySoft.Libraries;
    ///
    ///class Example
    ///{
    ///    private static Cache&lt;int, bool&gt; isPrimeCache;
    ///
    ///    public static void Main()
    ///    {
    ///        // Cache capacity is initialized to store maximum 4 values
    ///        isPrimeCache = new Cache&lt;int, bool&gt;(ItemLoader, 4);
    ///        // If cache is full the least recent used element will be deleted
    ///        isPrimeCache.Behavior = CacheBehavior.RemoveLeastRecentUsedElement;
    ///
    ///        // cache is now empty
    ///        DumpCache();
    ///
    ///        // reading the cache invokes the loader method
    ///        CheckPrime(13);
    ///
    ///        // reading a few more values
    ///        CheckPrime(23);
    ///        CheckPrime(33);
    ///        CheckPrime(43);
    ///
    ///        // dumping content
    ///        DumpCache();
    ///
    ///        // accessing an already read item does not invoke loader again
    ///        // Now it changes cache order because of the chosen behavior
    ///        CheckPrime(13);
    ///        DumpCache();
    ///
    ///        // reading a new element with full cache will delete an old one (now 23)
    ///        CheckPrime(111);
    ///        DumpCache();
    ///
    ///        // but accessing a deleted element causes to load it again
    ///        CheckPrime(23);
    ///        DumpCache();
    ///
    ///        // dumping some statistics
    ///        Console.WriteLine(isPrimeCache.GetStatistics().ToString());
    ///    }
    ///
    ///    // This is the item loader method. It can access database or perform slow calculations.
    ///    // If cache is meant to be serialized it should be a static method rather than an anonymous delegate or lambda expression.
    ///    private static bool ItemLoader(int number)
    ///    {
    ///        Console.WriteLine("Item loading has been invoked for value {0}", number);
    ///
    ///        // In this example item loader checks whether the given number is a prime by a not too efficient algorithm.
    ///        if (number &lt;= 1)
    ///            return false;
    ///        if (number % 2 == 0)
    ///            return true;
    ///        int i = 3;
    ///        int sqrt = (int)Math.Floor(Math.Sqrt(number));
    ///        while (i &lt;= sqrt)
    ///        {
    ///            if (number % i == 0)
    ///                return false;
    ///            i += 2;
    ///        }
    ///
    ///        return true;
    ///    }
    ///
    ///    private static void CheckPrime(int number)
    ///    {
    ///        // cache is used transparently here: indexer is always just read
    ///        bool isPrime = isPrimeCache[number];
    ///        Console.WriteLine("{0} is a prime: {1}", number, isPrime);
    ///    }
    ///
    ///    private static void DumpCache()
    ///    {
    ///        Console.WriteLine();
    ///        Console.WriteLine("Cache elements count: {0}", isPrimeCache.Count);
    ///        if (isPrimeCache.Count &gt; 0)
    ///        {
    ///            // enumerating through the cache shows the elements in the evaluation order
    ///            Console.WriteLine("Cache elements:");
    ///            foreach (KeyValuePair&lt;int, bool&gt; item in isPrimeCache)
    ///            {
    ///                Console.WriteLine("\tKey: {0},\tValue: {1}", item.Key, item.Value);
    ///            }
    ///        }
    ///        Console.WriteLine();
    ///    }
    ///}
    /// /* This code example produces the following output:
    /// 
    ///Cache elements count: 0
    ///
    ///Item loading has been invoked for value 13
    ///13 is a prime: True
    ///Item loading has been invoked for value 23
    ///23 is a prime: True
    ///Item loading has been invoked for value 33
    ///33 is a prime: False
    ///Item loading has been invoked for value 43
    ///43 is a prime: True
    ///
    ///Cache elements count: 4
    ///Cache elements:
    ///        Key: 13,        Value: True
    ///        Key: 23,        Value: True
    ///        Key: 33,        Value: False
    ///        Key: 43,        Value: True
    ///
    ///13 is a prime: True
    ///
    ///Cache elements count: 4
    ///Cache elements:
    ///        Key: 23,        Value: True
    ///        Key: 33,        Value: False
    ///        Key: 43,        Value: True
    ///        Key: 13,        Value: True
    ///
    ///Item loading has been invoked for value 111
    ///111 is a prime: False
    ///
    ///Cache elements count: 4
    ///Cache elements:
    ///        Key: 33,        Value: False
    ///        Key: 43,        Value: True
    ///        Key: 13,        Value: True
    ///        Key: 111,       Value: False
    ///
    ///Item loading has been invoked for value 23
    ///23 is a prime: True
    ///
    ///Cache elements count: 4
    ///Cache elements:
    ///        Key: 43,        Value: True
    ///        Key: 13,        Value: True
    ///        Key: 111,       Value: False
    ///        Key: 23,        Value: True
    ///
    ///Cache&lt;Int32, Boolean&gt; cache statistics:
    ///Count: 4
    ///Capacity: 4
    ///Number of writes: 6
    ///Number of reads: 7
    ///Number of cache hits: 1
    ///Number of deletes: 2
    ///Hit rate: 14,29%
    /// */
    /// </code></example>
    /// <seealso cref="CacheBehavior"/>
    [Serializable]
    [DebuggerTypeProxy(typeof(DictionaryDebugView<,>))]
    [DebuggerDisplay("Count = {Count}; TKey = {typeof(TKey)}; TValue = {typeof(TValue)}; Hit = {GetStatistics().HitRate * 100}%")]
    public sealed class Cache<TKey, TValue> : IDictionary<TKey, TValue>, ICache, ISerializable
    {
        #region Nested Types

        /// <summary>
        /// Enumerates the elements of a <see cref="Cache{TKey,TValue}"/> instance in the evaluation order.
        /// </summary>
        /// <seealso cref="Cache{TKey,TValue}"/>
        [Serializable, StructLayout(LayoutKind.Sequential)]
        public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>, IDictionaryEnumerator
        {
            #region Fields

            private readonly Cache<TKey, TValue> cache;
            private readonly int version;
            private readonly bool isGeneric;
            private CacheItem<TKey, TValue> current;
            private bool beforeFirst;

            #endregion

            #region Constructor

            internal Enumerator(Cache<TKey, TValue> cache, bool isGeneric)
            {
                this.cache = cache;
                version = cache.version;
                current = null;
                this.isGeneric = isGeneric;
                beforeFirst = true;
            }

            #endregion

            #region IEnumerator<KeyValuePair<TKey,TValue>> Members

            /// <summary>
            /// Gets the element at the current position of the enumerator.
            /// </summary>
            public KeyValuePair<TKey, TValue> Current
            {
                get
                {
                    if (current != null)
                        return new KeyValuePair<TKey, TValue>(current.Key, current.Value);

                    return default(KeyValuePair<TKey, TValue>);
                }
            }

            #endregion

            #region IDisposable Members

            /// <summary>
            /// Releases the enumerator
            /// </summary>
            public void Dispose()
            {
            }

            #endregion

            #region IEnumerator Members

            object IEnumerator.Current
            {
                get
                {
                    if (beforeFirst || (!beforeFirst && current == null))
                        throw new InvalidOperationException("Enumeration has either not started or has already finished.");
                    if (isGeneric)
                        return Current;
                    return new DictionaryEntry(current.Key, current.Value);
                }
            }

            /// <summary>
            /// Advances the enumerator to the next element of the collection.
            /// </summary>
            /// <returns>
            /// <c>true</c> if the enumerator was successfully advanced to the next element; <c>false</c> if the enumerator has passed the end of the collection.
            /// </returns>
            /// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
            public bool MoveNext()
            {
                if (version != cache.version)
                    throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");

                if (beforeFirst)
                {
                    beforeFirst = false;
                    if (cache.first == null)
                        return false;

                    current = cache.first;
                    return true;
                }

                if (current != null)
                {
                    current = current.Next;
                    return current != null;
                }

                return false;
            }

            /// <summary>
            /// Sets the enumerator to its initial position, which is before the first element in the collection.
            /// </summary>
            /// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
            public void Reset()
            {
                if (version != cache.version)
                    throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");
                beforeFirst = true;
                current = null;
            }

            #endregion

            #region IDictionaryEnumerator Members

            DictionaryEntry IDictionaryEnumerator.Entry
            {
                get
                {
                    if (beforeFirst || (!beforeFirst && current == null))
                        throw new InvalidOperationException("Enumeration has either not started or has already finished.");
                    return new DictionaryEntry(current.Key, current.Value);
                }
            }

            object IDictionaryEnumerator.Key
            {
                get
                {
                    if (beforeFirst || (!beforeFirst && current == null))
                        throw new InvalidOperationException("Enumeration has either not started or has already finished.");
                    return current.Key;
                }
            }

            object IDictionaryEnumerator.Value
            {
                get
                {
                    if (beforeFirst || (!beforeFirst && current == null))
                        throw new InvalidOperationException("Enumeration has either not started or has already finished.");
                    return current.Value;
                }
            }

            #endregion
        }

        /// <summary>
        /// Retrieves statistics of a <see cref="Cache{TKey,TValue}"/> instance.
        /// </summary>
        [Serializable]
        public struct CacheStatistics : ICacheStatistics
        {
            readonly Cache<TKey, TValue> owner;

            /// <summary>
            /// Gets number of cache reads.
            /// </summary>
            public int Reads { get { return owner.cacheReads; } }

            /// <summary>
            /// Gets number of cache writes.
            /// </summary>
            public int Writes { get { return owner.cacheWrites; } }

            /// <summary>
            /// Gets number of cache deletes.
            /// </summary>
            public int Deletes { get { return owner.cacheDeletes; } }

            /// <summary>
            /// Gets number of cache hits.
            /// </summary>
            public int Hits { get { return owner.cacheHit; } }

            /// <summary>
            /// Gets the hit rate of the cache
            /// </summary>
            public float HitRate { get { return Reads == 0 ? 0 : (float)Hits / Reads; } }

            internal CacheStatistics(Cache<TKey, TValue> owner)
            {
                this.owner = owner;
            }

            /// <summary>
            /// Gets the statistics of the cache as a string.
            /// </summary>
            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendFormat("Cache<{0}, {1}> cache statistics:{2}", typeof(TKey).Name, typeof(TValue).Name, Environment.NewLine);
                sb.AppendLine("Count: " + owner.Count);
                sb.AppendLine("Capacity: " + owner.Capacity);
                sb.AppendLine("Number of writes: " + Writes);
                sb.AppendLine("Number of reads: " + Reads);
                sb.AppendLine("Number of cache hits: " + Hits);
                sb.AppendLine("Number of deletes: " + Deletes);
                sb.AppendLine("Hit rate: " + HitRate.ToString("P2"));
                return sb.ToString();
            }
        }

        [Serializable]
        [DebuggerDisplay("[{Key}; {Value}]")]
        private sealed class CacheItem<TK, TV>
            where TK : TKey
            where TV : TValue
        {
            internal TK Key;
            internal TV Value;
            internal CacheItem<TK, TV> Next;
            internal CacheItem<TK, TV> Prev;
        }

        #endregion

        #region Fields

        #region Private fields

        private int cacheReads;
        private int cacheHit;
        private int cacheDeletes;
        private int capacity;
        private int cacheWrites;
        private bool ensureCapacity = true;
        private readonly bool isDefaultComparer;

        private int version;
        private Dictionary<TKey, CacheItem<TKey, TValue>> cacheStore;
        private readonly Func<TKey, TValue> itemLoader;
        private readonly IEqualityComparer<TKey> comparer;
        private object syncRoot;

        /// <summary>
        /// First element in the evaluation order. This element will be dropped first as least used item.
        /// </summary>
        private CacheItem<TKey, TValue> first;

        /// <summary>
        /// Last (newest) element in the evaluation order.
        /// </summary>
        private CacheItem<TKey, TValue> last;

        #endregion

        #region Public fields

        /// <summary>
        /// A loader that can be used at constructors if you manage element additions to the cache manually.
        /// If you want to get an element with a non-existing key using this loader, a <see cref="KeyNotFoundException"/> will be thrown.
        /// This field is read-only.
        /// </summary>
        public static readonly Func<TKey, TValue> NullLoader = TKey => { throw new KeyNotFoundException("If you use NullLoader in Cache<TKey, TValue>, then elements must be added excplicity either by Add method or the setter of the indexer!"); };

        #endregion

        #endregion

        #region Properties and Indexers

        #region Properties

        /// <summary>
        /// Gets or sets the capacity of the cache. If new value is smaller than elements count,
        /// then old or least used elements (depending on <see cref="Behavior"/>) will be removed from cache.
        /// </summary>
        public int Capacity
        {
            get { return capacity; }
            set
            {
                if (value <= 0)
                    throw new ArgumentOutOfRangeException("value", "Minimum cache size is 1");
                bool ensure = ensureCapacity && value != capacity;
                capacity = value;
                if (Count - value > 0)
                    RemoveLeastUsedItems(Count - value);

                if (ensure)
                    DoEnsureCapacity();
            }
        }

        /// <summary>
        /// Element count
        /// </summary>
        public int Count
        {
            get { return (cacheStore == null) ? 0 : cacheStore.Count; }
        }

        /// <summary>
        /// Gets or sets the cache behavior when cache is full and an element has to be removed.
        /// <para>
        /// Default value: <see cref="CacheBehavior.RemoveOldestElement"/>.
        /// </para>
        /// <note>
        /// Changing value of this property will not reorganize cache. Cache order is maintaned on accessing a value.
        /// </note>
        /// </summary>
        /// <seealso cref="CacheBehavior"/>
        public CacheBehavior Behavior { get; set; }

        /// <summary>
        /// Gets or sets whether adding the first item to the cache or resetting <see cref="Capacity"/> on a non-empty cache should
        /// allocate memory for all cache entries. Default value is <c>true</c>. Should be disabled for very large <see cref="Capacity"/>.
        /// </summary>
        public bool EnsureCapacity
        {
            get { return ensureCapacity; }
            set
            {
                ensureCapacity = value;
                if (ensureCapacity)
                    DoEnsureCapacity();
            }
        }

        /// <summary>
        /// Returns a copy of the keys stored in the cache in evaluation order.
        /// </summary>
        public ICollection<TKey> Keys
        {
            get
            {
                if (cacheStore == null || first == null)
                    return new TKey[0];

                TKey[] keys = new TKey[Count];
                int i = 0;
                for (CacheItem<TKey, TValue> current = first; current != null; current = current.Next)
                {
                    keys[i++] = current.Key;                    
                }

                Debug.Assert(i == Count, "Count mismatch in Keys");
                return keys;
            }
        }

        /// <summary>
        /// Returns a copy of the values stored in the cache in evaluation order.
        /// </summary>
        public ICollection<TValue> Values
        {
            get
            {
                if (cacheStore == null || first == null)
                    return new TValue[0];

                TValue[] values = new TValue[Count];
                int i = 0;
                for (CacheItem<TKey, TValue> current = first; current != null; current = current.Next)
                {
                    values[i++] = current.Value;
                }

                Debug.Assert(i == Count, "Count mismatch in Values");
                return values;
            }
        }

        #endregion

        #region Indexers

        /// <summary>
        /// Gets or sets the value of given <paramref name="key"/>.
        /// Getter retrieves the needed element, while setter adds a new item (or overwrites an already existing item).
        /// Normally only the get accessor should be used because that will load elements into the cache by the item loader passed to the constructor.
        /// </summary>
        /// <param name="key">Key of the element to get or set.</param>
        public TValue this[TKey key]
        {
            get { return GetValue(key); }
            set
            {
                CacheItem<TKey, TValue> element;
                if (cacheStore != null && cacheStore.TryGetValue(key, out element))
                {
                    if (Behavior == CacheBehavior.RemoveLeastRecentUsedElement)
                        InternalTouch(element);

                    // replacing original value
                    element.Value = value;
                    version++;
                }
                else
                {
                    Insert(key, value);
                }
            }
        }

        #endregion

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new cache instance with the given <paramref name="itemLoader"/>, <paramref name="capacity"/> and <paramref name="comparer"/>.
        /// </summary>
        /// <param name="capacity">Capacity of the cache, (maximum element count)</param>
        /// <param name="itemLoader">A delegate that contains the item loader routine.
        /// This delegate is accessed whenever a non-cached item is need to be loaded. If you want to add items manually, you can use <see cref="NullLoader"/>
        /// that will thow a <see cref="KeyNotFoundException"/> on accessing a non-existing key.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> instance that can be used for key comparison in the cache. For example,
        /// you can use <see cref="StringComparer.InvariantCultureIgnoreCase"/> comparer for a case-insensitive cache with string key
        /// or <see cref="EnumComparer{TEnum}.Comparer"/> for fast access cache with enum key.</param>
        /// <overloads><see cref="Cache{TKey,TValue}"/> type has four different public constructors for initializing the item loader delegate, capacity and key comparer.</overloads>
        public Cache(Func<TKey, TValue> itemLoader, int capacity, IEqualityComparer<TKey> comparer)
        {
            Behavior = CacheBehavior.RemoveOldestElement;
            if (itemLoader == null)
                throw new ArgumentNullException("itemLoader", "You must define a valid item loader that can be called when an element is not loaded into the cache. " +
                                                              "If you want to add cache elements explicitly, use Cache<TKey, TValue>.NullLoader");
            this.itemLoader = itemLoader;
            Capacity = capacity;
            this.comparer = comparer ?? EqualityComparer<TKey>.Default;
            isDefaultComparer = this.comparer.Equals(EqualityComparer<TKey>.Default);
        }

        /// <summary>
        /// Creates a new cache instance with the given <paramref name="itemLoader"/> and sets cache <see cref="Capacity"/> to 100.
        /// </summary>
        /// <param name="itemLoader">A delegate that contains the item loader routine.
        /// This delegate is accessed whenever a non-cached item is need to be loaded. If you want to add items manually, you can use <see cref="NullLoader"/>
        /// that will thow a <see cref="KeyNotFoundException"/> on accessing a non-existing key.</param>
        public Cache(Func<TKey, TValue> itemLoader)
            : this(itemLoader, 100, null)
        {
        }

        /// <summary>
        /// Creates a new cache instance with the given <paramref name="itemLoader"/>.
        /// </summary>
        /// <param name="capacity">Capacity of the cache, (maximum element count)</param>
        /// <param name="itemLoader">A delegate that contains the item loader routine.
        /// This delegate is accessed whenever a non-cached item is need to be loaded. If you want to add items manually, you can use <see cref="NullLoader"/>
        /// that will thow a <see cref="KeyNotFoundException"/> on accessing a non-existing key.</param>
        public Cache(Func<TKey, TValue> itemLoader, int capacity)
            : this(itemLoader, capacity, null)
        {
        }

        /// <summary>
        /// Creates a new cache instance with the given <paramref name="itemLoader"/> and <paramref name="comparer"/> and sets cache capacity to 100.
        /// </summary>
        /// <param name="itemLoader">A delegate that contains the item loader routine.
        /// This delegate is accessed whenever a non-cached item is need to be loaded.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> instance that can be used for key comparison in the cache. For example,
        /// you can use <see cref="StringComparer.InvariantCultureIgnoreCase"/> comparer for a case-insensitive cache with string key.</param>
        public Cache(Func<TKey, TValue> itemLoader, IEqualityComparer<TKey> comparer)
            : this(itemLoader, 100, comparer)
        {
        }

        #endregion

        #region Methods

        #region Public Methods

        /// <summary>
        /// Adding new element to the cache. If the element already exists in the cache, an exception will be thrown.
        /// In contrast, using the setter of the indexer (see <see cref="this"/>) replaces the old value with the new one.
        /// If you want to renew an element in the evaluation order, use the <see cref="Touch"/> method.
        /// Normally you do not need to call this method,
        /// unless you have constructed the cache with the <see cref="NullLoader"/> item loader.
        /// </summary>
        /// <param name="key">The key of the element to add.</param>
        /// <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference types.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="key"/> already exists in the cache.</exception>
        public void Add(TKey key, TValue value)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            if (cacheStore != null && cacheStore.ContainsKey(key))
                throw new ArgumentException("An item with the same key has already been added.", "key");
            Insert(key, value);
        }

        /// <summary>
        /// Removes an item from the cache.
        /// </summary>
        /// <param name="key">Key of the item to remove.</param>
        /// <returns>true if the element is successfully removed; otherwise, false. This method also returns false if key was not found in the cache.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        public bool Remove(TKey key)
        {
            CacheItem<TKey, TValue> element;
            if (cacheStore != null && cacheStore.TryGetValue(key, out element))
            {
                InternalRemove(element);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Renewes an item in the evaluation order.
        /// </summary>
        /// <param name="key">The key of the item to renew.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="key"/> must exist in the cache.</exception>
        public void Touch(TKey key)
        {
            CacheItem<TKey, TValue> element;
            if (cacheStore != null && cacheStore.TryGetValue(key, out element))
            {
                InternalTouch(element);
                version++;
            }
            else
                throw new ArgumentException("Key " + key + " does not exist in cache.");
        }


        /// <summary>
        /// Tries to gets the value associated with the specified key without using the item loader passed to the constructor.
        /// </summary>
        /// <returns>
        /// <c>true</c>, if cache contains an element with the specified key; otherwise, <c>false</c>.
        /// </returns>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        public bool TryGetValue(TKey key, out TValue value)
        {
            cacheReads++;
            if (cacheStore == null)
            {
                value = default(TValue);
                return false;
            }

            CacheItem<TKey, TValue> element;
            if (cacheStore.TryGetValue(key, out element))
            {
                cacheHit++;
                if (Behavior == CacheBehavior.RemoveLeastRecentUsedElement)
                    InternalTouch(element);

                value = element.Value;
                return true;
            }

            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Refreshes the value in the cache even if it was already loaded.
        /// </summary>
        /// <param name="key">The key of the item to refresh.</param>
        public void RefreshValue(TKey key)
        {
            GetValueUncached(key);
        }

        /// <summary>
        /// Reloads the value into the cache even if it was already loaded using the item loader that was passed to the constructor.
        /// </summary>
        /// <param name="key">The key of the item to reload.</param>
        /// <returns>Loaded value</returns>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        public TValue GetValueUncached(TKey key)
        {
            if (key == null)
                throw new ArgumentNullException("key");

            TValue result = itemLoader(key);
            CacheItem<TKey, TValue> element;
            if (cacheStore != null && cacheStore.TryGetValue(key, out element))
            {
                if (Behavior == CacheBehavior.RemoveLeastRecentUsedElement)
                    InternalTouch(element);

                element.Value = result;
                cacheWrites++;
                version++;
                return result;
            }

            Insert(key, result);
            return result;
        }

        /// <summary>
        /// Gets whether a value is stored in the cache with the given key.
        /// </summary>
        /// <param name="key">The key of the item to check.</param>
        public bool ContainsKey(TKey key)
        {
            return (cacheStore != null && cacheStore.ContainsKey(key));
        }

        /// <summary>
        /// Clears the cache.
        /// </summary>
        public void Clear()
        {
            cacheDeletes += Count;
            first = null;
            last = null;
            cacheStore = null;
            version++;
        }

        /// <summary>
        /// Clears the cache and resets statistics.
        /// </summary>
        public void Reset()
        {
            Clear();
            cacheReads = 0;
            cacheWrites = 0;
            cacheDeletes = 0;
            cacheHit = 0;
        }

        /// <summary>
        /// Gets statistics of the cache.
        /// </summary>
        public ICacheStatistics GetStatistics()
        {
            return new CacheStatistics(this);
        }

        #endregion

        #region Private Methods

        private void DoEnsureCapacity()
        {
            if (cacheStore == null)
                return;

            var old = cacheStore;
            cacheStore = new Dictionary<TKey, CacheItem<TKey, TValue>>(capacity, comparer);
            foreach (KeyValuePair<TKey, CacheItem<TKey, TValue>> pair in old)
            {
                cacheStore.Add(pair.Key, pair.Value);
            }
        }

        /// <summary>
        /// Gets a value from the cache. If item  does not exists in cache, loads it by the item loader that was passed to the constructor.
        /// </summary>
        /// <param name="key">The key of the item to load.</param>
        private TValue GetValue(TKey key)
        {
            cacheReads++;

            CacheItem<TKey, TValue> element;
            if (cacheStore != null && cacheStore.TryGetValue(key, out element))
            {
                cacheHit++;
                if (Behavior == CacheBehavior.RemoveLeastRecentUsedElement)
                    InternalTouch(element);
                return element.Value;
            }
            else
            {
                TValue newItem = itemLoader(key);
                Insert(key, newItem);
                return newItem;
            }
        }

        private void InternalTouch(CacheItem<TKey, TValue> element)
        {
            if (last == element)
                return;

            // extracting from middle
            if (element != first)
                element.Prev.Next = element.Next;
            element.Next.Prev = element.Prev; // element.Next is never null because because element is not last

            // adjusting first
            Debug.Assert(first != null, "first is null at InternalTouch");
            if (first == element)
                first = first.Next;

            // setting prev/next/last
            element.Prev = last;
            element.Next = null;
            last.Next = element;
            last = element;
        }

        private void InternalRemove(CacheItem<TKey, TValue> element)
        {
            cacheStore.Remove(element.Key);

            // adjusting first/last
            if (last == element)
                last = element.Prev;
            if (first == element)
                first = element.Next;

            // extracting from middle
            if (element.Prev != null)
                element.Prev.Next = element.Next;
            if (element.Next != null)
                element.Next.Prev = element.Prev;

            cacheDeletes++;
            version++;
        }

        /// <summary>
        /// Removes the least used item from the cache.
        /// </summary>
        private void RemoveLeastUsedItem()
        {
            Debug.Assert(first != null, "first is null at RemoveLeastUsedItem");
            cacheStore.Remove(first.Key);
            first = first.Next;
            if (first != null)
                first.Prev = null;
            cacheDeletes++;
            version++;
        }

        private void RemoveLeastUsedItems(int amount)
        {
            Debug.Assert(Count >= amount, "Count is too few in RemoveLeastUsedItems");
            for (int i = 0; i < amount; i++)
            {
                Debug.Assert(first != null, "first is null at RemoveLeastUsedItems");
                cacheStore.Remove(first.Key);
                first = first.Next;
                if (first != null)
                    first.Prev = null;
            }

            cacheDeletes += amount;
            version++;
        }

        /// <summary>
        /// Inserting a new element into the cache
        /// </summary>
        private void Insert(TKey key, TValue value)
        {
            if (cacheStore == null)
            {
                cacheStore = new Dictionary<TKey, CacheItem<TKey, TValue>>(ensureCapacity ? capacity : 1, comparer);
            }

            if (cacheStore.Count >= capacity)
                RemoveLeastUsedItem();

            var element = new CacheItem<TKey, TValue>
            {
                Key = key,
                Value = value,
                Prev = last
            };

            cacheStore[key] = element;
            if (first == null)
                first = element;
            if (last != null)
                last.Next = element;
            last = element;

            cacheWrites++;
            version++;
        }

        #endregion

        #endregion

        #region Explicitly Implemented ICollection<KeyValuePair<TKey,TValue>> Members

        /// <summary>
        /// Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        void ICollection<KeyValuePair<TKey, TValue>>.Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
        /// </summary>
        /// <returns>
        /// true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
        /// </returns>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        bool ICollection<KeyValuePair<TKey, TValue>>.Contains(KeyValuePair<TKey, TValue> item)
        {
            if (cacheStore == null)
                return false;
            CacheItem<TKey, TValue> element;
            if (cacheStore.TryGetValue(item.Key, out element))
            {
                return EqualityComparer<TValue>.Default.Equals(item.Value, element.Value);
            }

            return false;
        }

        /// <summary>
        /// Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>,
        /// starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from
        /// <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0, or larger than length
        /// of <paramref name="array"/>.</exception>
        /// <exception cref="T:System.ArgumentException"><paramref name="arrayIndex"/> is equal to or greater than the length
        /// of <paramref name="array"/>.
        /// <br/>-or-
        /// <br/>The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available
        /// space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</exception>
        void ICollection<KeyValuePair<TKey, TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            if (array == null)
                throw new ArgumentNullException("array");
            if (arrayIndex < 0 || arrayIndex > array.Length)
                throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex");
            if (array.Length - arrayIndex < Count)
                throw new ArgumentException("Destination array is not long enough to copy all the items in the collection. Check array index and length.", "array");

            for (CacheItem<TKey, TValue> current = first; current != null; current = current.Next)
            {
                array[arrayIndex++] = new KeyValuePair<TKey, TValue>(current.Key, current.Value);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        /// </summary>
        /// <returns>
        /// This is always a <c>false</c> value for <see cref="Cache{TKey,TValue}"/>.
        /// </returns>
        bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly
        {
            get { return false; }
        }

        /// <summary>
        /// Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>
        /// true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>;
        /// otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original
        /// <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </returns>
        /// <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> item)
        {
            if (cacheStore == null)
                return false;
            
            CacheItem<TKey, TValue> element;
            if (cacheStore.TryGetValue(item.Key, out element) && EqualityComparer<TValue>.Default.Equals(item.Value, element.Value))
            {
                InternalRemove(element);
                return true;
            }

            return false;
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey,TValue>> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            return new Enumerator(this, true);
        }

        #endregion

        #region Explicitly Implemented IEnumerable Members

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return new Enumerator(this, true);
        }

        #endregion

        #region ICache Members

        /// <summary>
        /// Renewes an item in the evaluation order.
        /// </summary>
        /// <param name="key">The key of the item to renew.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="key"/> must exist in the cache.</exception>
        void ICache.Touch(object key)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            if (!typeof(TKey).CanAcceptValue(key))
                throw new ArgumentException("Type of key is invalid", "key");
            Touch((TKey)key);
        }

        /// <summary>
        /// Refreshes the value in the cache even if it was already loaded.
        /// </summary>
        /// <param name="key">The key of the item to refresh.</param>
        void ICache.RefreshValue(object key)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            if (!typeof(TKey).CanAcceptValue(key))
                throw new ArgumentException("Type of key is invalid", "key");
            RefreshValue((TKey)key);
        }

        /// <summary>
        /// Reloads the value into the cache even if it was already loaded using the item loader that was passed to the constructor.
        /// </summary>
        /// <param name="key">The key of the item to reload.</param>
        /// <returns>Loaded value</returns>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> must not be <see langword="null"/>.</exception>
        object ICache.GetValueUncached(object key)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            if (!typeof(TKey).CanAcceptValue(key))
                throw new ArgumentException("Type of key is invalid", "key");
            return GetValueUncached((TKey)key);
        }

        #endregion

        #region IDictionary Members

        /// <summary>
        /// Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"/> object.
        /// </summary>
        /// <param name="key">The <see cref="T:System.Object"/> to use as the key of the element to add.</param>
        /// <param name="value">The <see cref="T:System.Object"/> to use as the value of the element to add.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        /// <exception cref="T:System.ArgumentException"><paramref name="key"/> or <paramref name="value"/> has an invalid type
        /// <br/>-or-
        /// <br/>An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"/> object.</exception>
        void IDictionary.Add(object key, object value)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            if (!typeof(TKey).CanAcceptValue(key))
                throw new ArgumentException("Type of key is invalid", "key");
            if (!typeof(TValue).CanAcceptValue(value))
                throw new ArgumentException("Type of key is invalid", "value");
            Add((TKey)key, (TValue)value);
        }

        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.IDictionary"/> object contains an element with the specified key.
        /// </summary>
        /// <returns>
        /// true if the <see cref="T:System.Collections.IDictionary"/> contains an element with the key; otherwise, false.
        /// </returns>
        /// <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"/> object.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        bool IDictionary.Contains(object key)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            return key is TKey && ContainsKey((TKey)key);
        }

        /// <summary>
        /// Returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> object for the
        /// <see cref="T:System.Collections.IDictionary"/> object.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IDictionaryEnumerator"/> object for the <see cref="T:System.Collections.IDictionary"/> object.
        /// </returns>
        IDictionaryEnumerator IDictionary.GetEnumerator()
        {
            return new Enumerator(this, false);
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"/> object has a fixed size.
        /// </summary>
        /// <returns>
        /// This is always a <c>false</c> value for <see cref="Cache{TKey,TValue}"/>.
        /// </returns>
        bool IDictionary.IsFixedSize
        {
            get { return false; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"/> object is read-only.
        /// </summary>
        /// <returns>
        /// This is always a <c>false</c> value for <see cref="Cache{TKey,TValue}"/>.
        /// </returns>
        bool IDictionary.IsReadOnly
        {
            get { return false; }
        }

        /// <summary>
        /// Gets an <see cref="T:System.Collections.ICollection"/> object containing the keys of the <see cref="T:System.Collections.IDictionary"/> object.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.ICollection"/> object containing the keys of the <see cref="T:System.Collections.IDictionary"/> object.
        /// </returns>
        ICollection IDictionary.Keys
        {
            get { return (ICollection)Keys; }
        }

        /// <summary>
        /// Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"/> object.
        /// </summary>
        /// <param name="key">The key of the element to remove.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        void IDictionary.Remove(object key)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            if (key is TKey)
                Remove((TKey)key);
        }

        /// <summary>
        /// Gets an <see cref="T:System.Collections.ICollection"/> object containing the values in the
        /// <see cref="T:System.Collections.IDictionary"/> object.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.ICollection"/> object containing the values in the <see cref="T:System.Collections.IDictionary"/> object.
        /// </returns>
        ICollection IDictionary.Values
        {
            get { return (ICollection)Values; }
        }

        /// <summary>
        /// Gets or sets the element with the specified key.
        /// </summary>
        /// <returns>
        /// The element with the specified key.
        /// </returns>
        /// <param name="key">The key of the element to get or set.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        /// <exception cref="T:System.ArgumentException"><paramref name="key"/> or <paramref name="value"/> has an invalid type.</exception>
        object IDictionary.this[object key]
        {
            get
            {
                if (key == null)
                    throw new ArgumentNullException("key");
                if (!typeof(TKey).CanAcceptValue(key))
                    throw new ArgumentException("Type of key is invalid", "key");
                return this[(TKey)key];
            }
            set
            {
                if (key == null)
                    throw new ArgumentNullException("key");
                if (!typeof(TKey).CanAcceptValue(key))
                    throw new ArgumentException("Type of key is invalid", "key");
                if (!typeof(TValue).CanAcceptValue(value))
                    throw new ArgumentException("Type of key is invalid", "value");
                this[(TKey)key] = (TValue)value;
            }
        }

        #endregion

        #region ICollection Members

        /// <summary>
        /// Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>,
        /// starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>.
        /// The <see cref="T:System.Array"/> must have zero-based indexing.</param>
        /// <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero,
        /// or larger that <paramref name="array"/> length.</exception>
        /// <exception cref="T:System.ArgumentException"><paramref name="array"/> is multidimensional.
        /// <br/>-or- 
        /// <br/>The number of elements in the source <see cref="T:System.Collections.ICollection"/> is greater
        /// than the available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.
        /// <br/>-or- 
        /// <br/>Element type of <paramref name="array"/> is neither <see cref="KeyValuePair{TKey,TValue}"/>,
        /// <see cref="DictionaryEntry"/> nor <see cref="object"/>.</exception>
        void ICollection.CopyTo(Array array, int index)
        {
            if (array == null)
                throw new ArgumentNullException("array");
            if (index < 0 || index > array.Length)
                throw new ArgumentOutOfRangeException("index");
            if (array.Length - index < Count)
                throw new ArgumentException("Destination array is not long enough to copy all the items in the collection. Check array index and length.", "index");
            if (array.Rank != 1)
                throw new ArgumentException("Only single dimensional arrays are supported for the requested action.", "array");
            if (first == null)
                return;

            KeyValuePair<TKey, TValue>[] keyValuePairs = array as KeyValuePair<TKey, TValue>[];
            if (keyValuePairs != null)
            {
                ((ICollection<KeyValuePair<TKey, TValue>>)this).CopyTo(keyValuePairs, index);
                return;
            }

            DictionaryEntry[] dictionaryEntries = array as DictionaryEntry[];
            if (dictionaryEntries != null)
            {
                for (CacheItem<TKey, TValue> current = first; current != null; current = current.Next)
                {
                    dictionaryEntries[index++] = new DictionaryEntry(current.Key, current.Value);
                }
            }

            object[] objectArray = array as object[];
            if (objectArray != null)
            {
                for (CacheItem<TKey, TValue> current = first; current != null; current = current.Next)
                {
                    objectArray[index++] = new KeyValuePair<TKey, TValue>(current.Key, current.Value);
                }
            }

            throw new ArgumentException("Target array type is not compatible with the type of items in the collection.");
        }

        bool ICollection.IsSynchronized
        {
            get { return false; }
        }

        object ICollection.SyncRoot
        {
            get
            {
                if (syncRoot == null)
                    Interlocked.CompareExchange(ref syncRoot, new object(), null);
                return syncRoot;
            }
        }

        #endregion

        //#region IBinarySerializable Members

        //byte[] IBinarySerializable.Serialize(BinarySerializationOptions options)
        //{
        //    MemoryStream ms = new MemoryStream();
        //    using (BinaryWriter bw = new BinaryWriter(ms))
        //    {
        //        // capacity
        //        bw.Write(capacity);
        //        bw.Write(ensureCapacity);

        //        // comparer
        //        bool isNullComparer = comparer == null;
        //        bw.Write(isNullComparer);
        //        if (!isNullComparer)
        //        {
        //            bool isDefaultComparer = comparer.Equals(EqualityComparer<TKey>.Default);
        //            bw.Write(isDefaultComparer);
        //            if (!isDefaultComparer)
        //                BinarySerializer.SerializeByWriter(bw, comparer, options);
        //        }

        //        // loader
        //        bool isNullLoader = itemLoader.Equals(NullLoader);
        //        bw.Write(isNullLoader);
        //        if (!isNullLoader)
        //            BinarySerializer.SerializeByWriter(bw, itemLoader, options);

        //        // elements
        //        int count = Count;
        //        bw.Write(count);
        //        if (count > 0)
        //        {
        //            BinarySerializer.SerializeByWriter(bw, Keys, options);
        //            BinarySerializer.SerializeByWriter(bw, Values, options);
        //        }

        //        // other data
        //        bw.Write(version);
        //        bw.Write(cacheReads);
        //        bw.Write(cacheWrites);
        //        bw.Write(cacheDeletes);
        //        bw.Write(cacheHit);
        //    }
        //    return ms.ToArray();
        //}

        ///// <summary>
        ///// The private constructor used for deserializing data
        ///// </summary>
        //private Cache(BinarySerializationOptions options, byte[] rawData)
        //{
        //    using (BinaryReader br = new BinaryReader(new MemoryStream(rawData)))
        //    {
        //        // capacity
        //        capacity = br.ReadInt32();
        //        ensureCapacity = br.ReadBoolean();

        //        // comparer
        //        bool isNullComparer = br.ReadBoolean();
        //        if (!isNullComparer)
        //        {
        //            bool isDefaultComparer = br.ReadBoolean();
        //            comparer = isDefaultComparer ? EqualityComparer<TKey>.Default : (IEqualityComparer<TKey>)BinarySerializer.DeserializeByReader(br);
        //        }

        //        // loader
        //        bool isNullLoader = br.ReadBoolean();
        //        itemLoader = isNullLoader ? NullLoader : (Func<TKey, TValue>)BinarySerializer.DeserializeByReader(br);

        //        // elements
        //        int count = br.ReadInt32();
        //        if (count > 0)
        //        {
        //            cacheStore = new Dictionary<TKey, TValue>(ensureCapacity ? capacity : count, comparer);
        //            cacheOrder = new CircularList<TKey>(ensureCapacity ? capacity : count);
        //            TKey[] keys = (TKey[])BinarySerializer.DeserializeByReader(br);
        //            TValue[] values = (TValue[])BinarySerializer.DeserializeByReader(br);
        //            for (int i = 0; i < count; i++)
        //            {
        //                cacheStore.Add(keys[i], values[i]);
        //                cacheOrder.Add(keys[i]);
        //            }
        //        }

        //        // other data
        //        version = br.ReadInt32();
        //        cacheReads = br.ReadInt32();
        //        cacheWrites = br.ReadInt32();
        //        cacheDeletes = br.ReadInt32();
        //        cacheHit = br.ReadInt32();
        //    }
        //}

        //void IBinarySerializable.Deserialize(BinarySerializationOptions options, byte[] serData)
        //{
        //    throw new InvalidOperationException("Deserialization is performed by the constructor");
        //}

        //#endregion

        #region ISerializable Members

        [SecurityCritical]
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
            // capacity
            info.AddValue("capacity", capacity);
            info.AddValue("ensureCapacity", ensureCapacity);

            // comparer
            info.AddValue("comparer", isDefaultComparer ? null : comparer);

            // loader
            info.AddValue("loader", itemLoader.Equals(NullLoader) ? null : itemLoader);

            // elements
            info.AddValue("keys", Keys);
            info.AddValue("values", Values);

            // other data
            info.AddValue("version", version);
            info.AddValue("reads", cacheReads);
            info.AddValue("writes", cacheWrites);
            info.AddValue("deletes", cacheDeletes);
            info.AddValue("hit", cacheHit);
        }

        /// <summary>
        /// Special constructor for deserialization
        /// </summary>
        private Cache(SerializationInfo info, StreamingContext context)
        {
            // capacity
            capacity = info.GetInt32("capacity");
            ensureCapacity = info.GetBoolean("ensureCapacity");

            // comparer
            comparer = (IEqualityComparer<TKey>)info.GetValue("comparer", typeof(IEqualityComparer<TKey>));
            isDefaultComparer = comparer == null;
            if (comparer == null)
                comparer = EqualityComparer<TKey>.Default;

            // loader
            itemLoader = (Func<TKey, TValue>)info.GetValue("loader", typeof(Func<TKey, TValue>)) ?? NullLoader;

            // elements
            TKey[] keys = (TKey[])info.GetValue("keys", typeof(TKey[]));
            TValue[] values = (TValue[])info.GetValue("values", typeof(TValue[]));
            cacheStore = new Dictionary<TKey, CacheItem<TKey, TValue>>(ensureCapacity ? capacity : keys.Length, comparer);
            for (int i = 0; i < keys.Length; i++)
            {
                Insert(keys[i], values[i]);
            }

            // other data
            version = info.GetInt32("version");
            cacheReads = info.GetInt32("reads");
            cacheDeletes = info.GetInt32("writes");
            cacheDeletes = info.GetInt32("deletes");
            cacheHit = info.GetInt32("hit");
        }

        #endregion
    }
}
